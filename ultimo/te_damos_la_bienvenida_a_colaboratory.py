# -*- coding: utf-8 -*-
"""Te damos la bienvenida a Colaboratory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

def balanceo_parentesis(expresion):
    pila = []
    parejas = {')': '(', ']': '[', '}': '{'}

    for caracter in expresion:
        if caracter in '([{':
            pila.append(caracter)
        elif caracter in ')]}':
            if not pila or pila[-1] != parejas[caracter]:
                return False
            pila.pop()

    return len(pila) == 0

# Prueba
print(balanceo_parentesis("({[]})"))  # True
print(balanceo_parentesis("({[})"))   # False

#2. Conversión infijo a postfijo
#Enunciado: Convierte una expresión matemática infija a notación postfija.
def infijo_a_postfijo(expresion):
    precedencia = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
    pila = []
    salida = []

    for token in expresion.split():
        if token.isalnum():
            salida.append(token)
        elif token == '(':
            pila.append(token)
        elif token == ')':
            while pila and pila[-1] != '(':
                salida.append(pila.pop())
            pila.pop()
        else:
            while (pila and pila[-1] != '(' and
                   precedencia.get(token, 0) <= precedencia.get(pila[-1], 0)):
                salida.append(pila.pop())
            pila.append(token)

    while pila:
        salida.append(pila.pop())

    return ' '.join(salida)

# Prueba
print(infijo_a_postfijo("( A + B ) * C"))  # A B + C *

#3. Evaluar expresión postfija
#Enunciado: Evalúa una expresión matemática en notación postfija.
def evaluar_postfijo(expresion):
    pila = []

    for token in expresion.split():
        if token.isdigit():
            pila.append(int(token))
        else:
            b = pila.pop()
            a = pila.pop()
            if token == '+': pila.append(a + b)
            elif token == '-': pila.append(a - b)
            elif token == '*': pila.append(a * b)
            elif token == '/': pila.append(a / b)

    return pila[0]

# Prueba
print(evaluar_postfijo("3 4 + 2 *"))  # 14

#4. Invertir una lista usando pila
#Enunciado: Invierte una lista usando operaciones de pila.
def invertir_lista_pila(lista):
    pila = []
    # Push todos los elementos a la pila
    for elemento in lista:
        pila.append(elemento)

    # Pop todos los elementos (saldrán en orden inverso)
    lista_invertida = []
    while pila:
        lista_invertida.append(pila.pop())

    return lista_invertida

# Prueba
print(invertir_lista_pila([1, 2, 3, 4, 5]))  # [5, 4, 3, 2, 1]

#5. Eliminar elementos consecutivos duplicados
#Enunciado: Elimina elementos duplicados consecutivos usando una pila.
def eliminar_consecutivos_duplicados(lista):
    pila = []

    for elemento in lista:
        if not pila or pila[-1] != elemento:
            pila.append(elemento)

    return pila

# Prueba
print(eliminar_consecutivos_duplicados([1, 2, 2, 3, 4, 4, 4, 5]))  # [1, 2, 3, 4, 5]

#6. Siguiente elemento mayor
#Enunciado: Para cada elemento, encuentra el primer elemento mayor a su derecha.
def siguiente_elemento_mayor(lista):
    pila = []
    resultado = [-1] * len(lista)

    for i in range(len(lista)):
        while pila and lista[pila[-1]] < lista[i]:
            idx = pila.pop()
            resultado[idx] = lista[i]
        pila.append(i)

    return resultado

# Prueba
print(siguiente_elemento_mayor([4, 5, 2, 10]))  # [5, 10, 10, -1]

#7. Validar secuencia de push/pop
#Enunciado: Verifica si una secuencia es válida para operaciones push/pop.
def validar_secuencia_push_pop(push_seq, pop_seq):
    pila = []
    i = 0

    for num in push_seq:
        pila.append(num)
        while pila and pila[-1] == pop_seq[i]:
            pila.pop()
            i += 1

    return not pila

# Prueba
print(validar_secuencia_push_pop([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]))  # True

#8. Pila con mínimo en O(1)
#Enunciado: Implementa una pila que devuelva el mínimo en tiempo constante.
class PilaConMinimo:
    def __init__(self):
        self.pila_principal = []
        self.pila_minimos = []

    def push(self, valor):
        self.pila_principal.append(valor)
        if not self.pila_minimos or valor <= self.pila_minimos[-1]:
            self.pila_minimos.append(valor)

    def pop(self):
        if not self.pila_principal:
            return None
        valor = self.pila_principal.pop()
        if valor == self.pila_minimos[-1]:
            self.pila_minimos.pop()
        return valor

    def min(self):
        return self.pila_minimos[-1] if self.pila_minimos else None

# Prueba
pila = PilaConMinimo()
pila.push(3)
pila.push(1)
pila.push(2)
print(pila.min())  # 1

#9. Dos pilas en un array
#Enunciado: Implementa dos pilas usando un solo array.
class DosPilas:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.array = [None] * capacidad
        self.top1 = -1
        self.top2 = capacidad

    def push1(self, valor):
        if self.top1 < self.top2 - 1:
            self.top1 += 1
            self.array[self.top1] = valor
        else:
            print("Pila 1 llena")

    def push2(self, valor):
        if self.top1 < self.top2 - 1:
            self.top2 -= 1
            self.array[self.top2] = valor
        else:
            print("Pila 2 llena")

    def pop1(self):
        if self.top1 >= 0:
            valor = self.array[self.top1]
            self.top1 -= 1
            return valor
        return None

    def pop2(self):
        if self.top2 < self.capacidad:
            valor = self.array[self.top2]
            self.top2 += 1
            return valor
        return None

# Prueba
pilas = DosPilas(5)
pilas.push1(1)
pilas.push2(2)
print(pilas.pop1())  # 1

#10. Ordenar pila
#Enunciado: Ordena una pila usando solo operaciones de pila.
def ordenar_pila(pila):
    pila_temp = []

    while pila:
        temp = pila.pop()
        while pila_temp and pila_temp[-1] > temp:
            pila.append(pila_temp.pop())
        pila_temp.append(temp)

    return pila_temp

# Prueba
pila = [3, 1, 4, 2]
print(ordenar_pila(pila))  # [1, 2, 3, 4]

##COLAS (10 ejercicios)
#11. Implementar cola usando pilas
#Enunciado: Implementa una cola usando dos pilas.
class ColaConPilas:
    def __init__(self):
        self.entrada = []
        self.salida = []

    def enqueue(self, valor):
        self.entrada.append(valor)

    def dequeue(self):
        if not self.salida:
            while self.entrada:
                self.salida.append(self.entrada.pop())
        return self.salida.pop() if self.salida else None

    def front(self):
        if not self.salida:
            while self.entrada:
                self.salida.append(self.entrada.pop())
        return self.salida[-1] if self.salida else None

# Prueba
cola = ColaConPilas()
cola.enqueue(1)
cola.enqueue(2)
print(cola.dequeue())  # 1

#12. Cola circular
#Enunciado: Implementa una cola circular con array de tamaño fijo.
class ColaCircular:
    def __init__(self, capacidad):
        self.capacidad = capacidad
        self.cola = [None] * capacidad
        self.frente = 0
        self.final = -1
        self.tamaño = 0

    def enqueue(self, valor):
        if self.tamaño == self.capacidad:
            return False
        self.final = (self.final + 1) % self.capacidad
        self.cola[self.final] = valor
        self.tamaño += 1
        return True

    def dequeue(self):
        if self.tamaño == 0:
            return None
        valor = self.cola[self.frente]
        self.frente = (self.frente + 1) % self.capacidad
        self.tamaño -= 1
        return valor

    def front(self):
        return self.cola[self.frente] if self.tamaño > 0 else None

# Prueba
cola = ColaCircular(3)
cola.enqueue(1)
cola.enqueue(2)
print(cola.dequeue())  # 1

#13. Revertir primeros k elementos
#Enunciado: Invierte los primeros k elementos de una cola.
def revertir_primeros_k(cola, k):
    pila = []

    # Sacar primeros k elementos a la pila
    for _ in range(k):
        pila.append(cola.dequeue())

    # Devolver de la pila a la cola (invertidos)
    while pila:
        cola.enqueue(pila.pop())

    # Mover los elementos restantes al final
    for _ in range(len(cola) - k):
        cola.enqueue(cola.dequeue())

    return cola

# Prueba (asumiendo implementación básica de cola)
class ColaSimple:
    def __init__(self):
        self.elementos = []

    def enqueue(self, valor):
        self.elementos.append(valor)

    def dequeue(self):
        return self.elementos.pop(0) if self.elementos else None

    def __len__(self):
        return len(self.elementos)

cola = ColaSimple()
for i in range(1, 6):
    cola.enqueue(i)
revertir_primeros_k(cola, 3)

#14. Generar números binarios
#Enunciado: Genera los primeros n números binarios usando una cola.
def generar_numeros_binarios(n):
    if n <= 0:
        return []

    resultado = []
    cola = []
    cola.append("1")

    for _ in range(n):
        actual = cola.pop(0)
        resultado.append(actual)
        cola.append(actual + "0")
        cola.append(actual + "1")

    return resultado

# Prueba
print(generar_numeros_binarios(5))  # ['1', '10', '11', '100', '101']

#15. Cola de prioridad simple
#Enunciado: Implementa una cola de prioridad usando listas.
class ColaPrioridadSimple:
    def __init__(self):
        self.elementos = []

    def enqueue(self, valor, prioridad):
        self.elementos.append((valor, prioridad))
        # Ordenar por prioridad (menor número = mayor prioridad)
        self.elementos.sort(key=lambda x: x[1])

    def dequeue(self):
        if not self.elementos:
            return None
        return self.elementos.pop(0)[0]

    def front(self):
        return self.elementos[0][0] if self.elementos else None

# Prueba
cp = ColaPrioridadSimple()
cp.enqueue("tarea1", 2)
cp.enqueue("tarea2", 1)
print(cp.dequeue())  # tarea2